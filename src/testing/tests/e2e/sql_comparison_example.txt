ENTRYPOINT DEBUG ACTIVE: src/shtest_compiler/shtest.py loaded
[DEBUG] Loaded patterns: ['step', 'action_result', 'action_only', 'result_only', 'comment']
[DEBUG] Pattern for step: ^(?:Étape|Etape|Step)\s*:\s*(.*)$
[DEBUG] Pattern for action_result: ^Action\s*:\s*(.*?)(?:\s*;\s*(?:R[ée]sultat|Resultat)\s*:\s*(.*)|\s*R[ée]sultat\s*:\s*(.*))$
[DEBUG] Pattern for action_only: ^Action\s*:\s*(.*)$
[DEBUG] Pattern for result_only: ^R[ée]sultat\s*:\s*(.*)$
[DEBUG] Pattern for comment: ^\s*#.*$
[DEBUG] Added STEP tokenizer with pattern: ^(?:Étape|Etape|Step)\s*:\s*(.*)$
[DEBUG] Added ACTION_RESULT tokenizer with pattern: ^Action\s*:\s*(.*?)(?:\s*;\s*(?:R[ée]sultat|Resultat)\s*:\s*(.*)|\s*R[ée]sultat\s*:\s*(.*))$
[DEBUG] Added ACTION_ONLY tokenizer with pattern: ^Action\s*:\s*(.*)$
[DEBUG] Added RESULT_ONLY tokenizer with pattern: ^R[ée]sultat\s*:\s*(.*)$
[DEBUG] Added COMMENT tokenizer with pattern: ^\s*#.*$
[DEBUG] Added FallbackTokenizer
[DEBUG] Parsing text with 35 lines
[DEBUG] Lexing text with 35 lines
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.STEP, value=Configuration de la base de données, result=('Configuration de la base de données',), original=Étape: Configuration de la base de données at line 1
[DEBUG] Yielding token: STEP@1:0 'Configuration de la base de données' -> '('Configuration de la base de données',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: définir la variable SQL_CONN = user/password@testdb at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: définir la variable SQL_CONN = user/password@testdb at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.ACTION_ONLY, value=définir la variable SQL_CONN = user/password@testdb, result=('définir la variable SQL_CONN = user/password@testdb',), original=Action: définir la variable SQL_CONN = user/password@testdb at line 1
[DEBUG] Yielding token: ACTION_ONLY@1:0 'définir la variable SQL_CONN = user/password@testdb' -> '('définir la variable SQL_CONN = user/password@testdb',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: variable SQL_CONN vaut user/password@testdb at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: variable SQL_CONN vaut user/password@testdb at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: variable SQL_CONN vaut user/password@testdb at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.RESULT_ONLY, value=variable SQL_CONN vaut user/password@testdb, result=('variable SQL_CONN vaut user/password@testdb',), original=Résultat: variable SQL_CONN vaut user/password@testdb at line 1
[DEBUG] Yielding token: RESULT_ONLY@1:0 'variable SQL_CONN vaut user/password@testdb' -> '('variable SQL_CONN vaut user/password@testdb',)'
[DEBUG] RegexTokenizer.tokenize: Yielding EMPTY token at line 1
[DEBUG] Yielding token: EMPTY@1:0 ''
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.STEP, value=Test d'export de requête simple, result=("Test d'export de requête simple",), original=Étape: Test d'export de requête simple at line 1
[DEBUG] Yielding token: STEP@1:0 'Test d'export de requête simple' -> '("Test d'export de requête simple",)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.ACTION_ONLY, value=exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx, result=('exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx',), original=Action: exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx at line 1
[DEBUG] Yielding token: ACTION_ONLY@1:0 'exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx' -> '('exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient Excel file created successfully at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient Excel file created successfully at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient Excel file created successfully at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.RESULT_ONLY, value=stdout contient Excel file created successfully, result=('stdout contient Excel file created successfully',), original=Résultat: stdout contient Excel file created successfully at line 1
[DEBUG] Yielding token: RESULT_ONLY@1:0 'stdout contient Excel file created successfully' -> '('stdout contient Excel file created successfully',)'
[DEBUG] RegexTokenizer.tokenize: Yielding EMPTY token at line 1
[DEBUG] Yielding token: EMPTY@1:0 ''
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.STEP, value=Test de comparaison de requêtes identiques, result=('Test de comparaison de requêtes identiques',), original=Étape: Test de comparaison de requêtes identiques at line 1
[DEBUG] Yielding token: STEP@1:0 'Test de comparaison de requêtes identiques' -> '('Test de comparaison de requêtes identiques',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT' at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT' at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.ACTION_ONLY, value=comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT', result=("comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT'",), original=Action: comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT' at line 1
[DEBUG] Yielding token: ACTION_ONLY@1:0 'comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT'' -> '("comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT'",)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.RESULT_ONLY, value=stdout contient COMPARISON_SUCCESS, result=('stdout contient COMPARISON_SUCCESS',), original=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] Yielding token: RESULT_ONLY@1:0 'stdout contient COMPARISON_SUCCESS' -> '('stdout contient COMPARISON_SUCCESS',)'
[DEBUG] RegexTokenizer.tokenize: Yielding EMPTY token at line 1
[DEBUG] Yielding token: EMPTY@1:0 ''
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.STEP, value=Test de comparaison avec tolérance numérique, result=('Test de comparaison avec tolérance numérique',), original=Étape: Test de comparaison avec tolérance numérique at line 1
[DEBUG] Yielding token: STEP@1:0 'Test de comparaison avec tolérance numérique' -> '('Test de comparaison avec tolérance numérique',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.ACTION_ONLY, value=comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees, result=('comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees',), original=Action: comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees at line 1
[DEBUG] Yielding token: ACTION_ONLY@1:0 'comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees' -> '('comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.RESULT_ONLY, value=stdout contient COMPARISON_SUCCESS, result=('stdout contient COMPARISON_SUCCESS',), original=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] Yielding token: RESULT_ONLY@1:0 'stdout contient COMPARISON_SUCCESS' -> '('stdout contient COMPARISON_SUCCESS',)'
[DEBUG] RegexTokenizer.tokenize: Yielding EMPTY token at line 1
[DEBUG] Yielding token: EMPTY@1:0 ''
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.STEP, value=Test d'exécution de requête simple, result=("Test d'exécution de requête simple",), original=Étape: Test d'exécution de requête simple at line 1
[DEBUG] Yielding token: STEP@1:0 'Test d'exécution de requête simple' -> '("Test d'exécution de requête simple",)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: exécuter la requête SELECT COUNT(*) FROM employees at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: exécuter la requête SELECT COUNT(*) FROM employees at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.ACTION_ONLY, value=exécuter la requête SELECT COUNT(*) FROM employees, result=('exécuter la requête SELECT COUNT(*) FROM employees',), original=Action: exécuter la requête SELECT COUNT(*) FROM employees at line 1
[DEBUG] Yielding token: ACTION_ONLY@1:0 'exécuter la requête SELECT COUNT(*) FROM employees' -> '('exécuter la requête SELECT COUNT(*) FROM employees',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient un nombre at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient un nombre at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient un nombre at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.RESULT_ONLY, value=stdout contient un nombre, result=('stdout contient un nombre',), original=Résultat: stdout contient un nombre at line 1
[DEBUG] Yielding token: RESULT_ONLY@1:0 'stdout contient un nombre' -> '('stdout contient un nombre',)'
[DEBUG] RegexTokenizer.tokenize: Yielding EMPTY token at line 1
[DEBUG] Yielding token: EMPTY@1:0 ''
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.STEP, value=Test d'export avec format personnalisé, result=("Test d'export avec format personnalisé",), original=Étape: Test d'export avec format personnalisé at line 1
[DEBUG] Yielding token: STEP@1:0 'Test d'export avec format personnalisé' -> '("Test d'export avec format personnalisé",)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.ACTION_ONLY, value=exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx, result=('exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx',), original=Action: exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx at line 1
[DEBUG] Yielding token: ACTION_ONLY@1:0 'exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx' -> '('exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient Excel file created successfully at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient Excel file created successfully at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient Excel file created successfully at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.RESULT_ONLY, value=stdout contient Excel file created successfully, result=('stdout contient Excel file created successfully',), original=Résultat: stdout contient Excel file created successfully at line 1
[DEBUG] Yielding token: RESULT_ONLY@1:0 'stdout contient Excel file created successfully' -> '('stdout contient Excel file created successfully',)'
[DEBUG] RegexTokenizer.tokenize: Yielding EMPTY token at line 1
[DEBUG] Yielding token: EMPTY@1:0 ''
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.STEP, value=Test de comparaison avec ordre ignoré, result=('Test de comparaison avec ordre ignoré',), original=Étape: Test de comparaison avec ordre ignoré at line 1
[DEBUG] Yielding token: STEP@1:0 'Test de comparaison avec ordre ignoré' -> '('Test de comparaison avec ordre ignoré',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison) at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison) at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.ACTION_ONLY, value=comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison), result=("comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)",), original=Action: comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison) at line 1
[DEBUG] Yielding token: ACTION_ONLY@1:0 'comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)' -> '("comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)",)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.RESULT_ONLY, value=stdout contient COMPARISON_SUCCESS, result=('stdout contient COMPARISON_SUCCESS',), original=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] Yielding token: RESULT_ONLY@1:0 'stdout contient COMPARISON_SUCCESS' -> '('stdout contient COMPARISON_SUCCESS',)'
[DEBUG] RegexTokenizer.tokenize: Yielding EMPTY token at line 1
[DEBUG] Yielding token: EMPTY@1:0 ''
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.STEP, value=Test de comparaison sans ordre - données identiques, result=('Test de comparaison sans ordre - données identiques',), original=Étape: Test de comparaison sans ordre - données identiques at line 1
[DEBUG] Yielding token: STEP@1:0 'Test de comparaison sans ordre - données identiques' -> '('Test de comparaison sans ordre - données identiques',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison) at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison) at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.ACTION_ONLY, value=comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison), result=("comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)",), original=Action: comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison) at line 1
[DEBUG] Yielding token: ACTION_ONLY@1:0 'comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)' -> '("comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)",)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.RESULT_ONLY, value=stdout contient COMPARISON_SUCCESS, result=('stdout contient COMPARISON_SUCCESS',), original=Résultat: stdout contient COMPARISON_SUCCESS at line 1
[DEBUG] Yielding token: RESULT_ONLY@1:0 'stdout contient COMPARISON_SUCCESS' -> '('stdout contient COMPARISON_SUCCESS',)'
[DEBUG] RegexTokenizer.tokenize: Yielding EMPTY token at line 1
[DEBUG] Yielding token: EMPTY@1:0 ''
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.STEP, value=Test de comparaison sans ordre - données différentes, result=('Test de comparaison sans ordre - données différentes',), original=Étape: Test de comparaison sans ordre - données différentes at line 1
[DEBUG] Yielding token: STEP@1:0 'Test de comparaison sans ordre - données différentes' -> '('Test de comparaison sans ordre - données différentes',)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison) at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Action: comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison) at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.ACTION_ONLY, value=comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison), result=("comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)",), original=Action: comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison) at line 1
[DEBUG] Yielding token: ACTION_ONLY@1:0 'comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)' -> '("comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)",)'
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_ERROR at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_ERROR at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding TEXT token value=Résultat: stdout contient COMPARISON_ERROR at line 1
[DEBUG] RegexTokenizer.tokenize: Yielding token type=TokenType.RESULT_ONLY, value=stdout contient COMPARISON_ERROR, result=('stdout contient COMPARISON_ERROR',), original=Résultat: stdout contient COMPARISON_ERROR  at line 1
[DEBUG] Yielding token: RESULT_ONLY@1:0 'stdout contient COMPARISON_ERROR' -> '('stdout contient COMPARISON_ERROR',)'
[DEBUG] Got 35 tokens
[DEBUG] Grammar: _merge_action_result called with 35 tokens
[DEBUG] Grammar: Token 0: kind=STEP, value='Configuration de la base de données'
[DEBUG] Grammar: Token 1: kind=ACTION_ONLY, value='définir la variable SQL_CONN = user/password@testdb'
[DEBUG] Grammar: Token 2: kind=RESULT_ONLY, value='variable SQL_CONN vaut user/password@testdb'
[DEBUG] Grammar: Token 3: kind=EMPTY, value=''
[DEBUG] Grammar: Token 4: kind=STEP, value='Test d'export de requête simple'
[DEBUG] Grammar: Token 5: kind=ACTION_ONLY, value='exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx'
[DEBUG] Grammar: Token 6: kind=RESULT_ONLY, value='stdout contient Excel file created successfully'
[DEBUG] Grammar: Token 7: kind=EMPTY, value=''
[DEBUG] Grammar: Token 8: kind=STEP, value='Test de comparaison de requêtes identiques'
[DEBUG] Grammar: Token 9: kind=ACTION_ONLY, value='comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT''
[DEBUG] Grammar: Token 10: kind=RESULT_ONLY, value='stdout contient COMPARISON_SUCCESS'
[DEBUG] Grammar: Token 11: kind=EMPTY, value=''
[DEBUG] Grammar: Token 12: kind=STEP, value='Test de comparaison avec tolérance numérique'
[DEBUG] Grammar: Token 13: kind=ACTION_ONLY, value='comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees'
[DEBUG] Grammar: Token 14: kind=RESULT_ONLY, value='stdout contient COMPARISON_SUCCESS'
[DEBUG] Grammar: Token 15: kind=EMPTY, value=''
[DEBUG] Grammar: Token 16: kind=STEP, value='Test d'exécution de requête simple'
[DEBUG] Grammar: Token 17: kind=ACTION_ONLY, value='exécuter la requête SELECT COUNT(*) FROM employees'
[DEBUG] Grammar: Token 18: kind=RESULT_ONLY, value='stdout contient un nombre'
[DEBUG] Grammar: Token 19: kind=EMPTY, value=''
[DEBUG] Grammar: Token 20: kind=STEP, value='Test d'export avec format personnalisé'
[DEBUG] Grammar: Token 21: kind=ACTION_ONLY, value='exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx'
[DEBUG] Grammar: Token 22: kind=RESULT_ONLY, value='stdout contient Excel file created successfully'
[DEBUG] Grammar: Token 23: kind=EMPTY, value=''
[DEBUG] Grammar: Token 24: kind=STEP, value='Test de comparaison avec ordre ignoré'
[DEBUG] Grammar: Token 25: kind=ACTION_ONLY, value='comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)'
[DEBUG] Grammar: Token 26: kind=RESULT_ONLY, value='stdout contient COMPARISON_SUCCESS'
[DEBUG] Grammar: Token 27: kind=EMPTY, value=''
[DEBUG] Grammar: Token 28: kind=STEP, value='Test de comparaison sans ordre - données identiques'
[DEBUG] Grammar: Token 29: kind=ACTION_ONLY, value='comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)'
[DEBUG] Grammar: Token 30: kind=RESULT_ONLY, value='stdout contient COMPARISON_SUCCESS'
[DEBUG] Grammar: Token 31: kind=EMPTY, value=''
[DEBUG] Grammar: Token 32: kind=STEP, value='Test de comparaison sans ordre - données différentes'
[DEBUG] Grammar: Token 33: kind=ACTION_ONLY, value='comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)'
[DEBUG] Grammar: Token 34: kind=RESULT_ONLY, value='stdout contient COMPARISON_ERROR'
[DEBUG] Grammar: Merging ACTION_ONLY 'définir la variable SQL_CONN = user/password@testdb' with RESULT_ONLY 'variable SQL_CONN vaut user/password@testdb'
[DEBUG] Grammar: Merging ACTION_ONLY 'exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx' with RESULT_ONLY 'stdout contient Excel file created successfully'
[DEBUG] Grammar: Merging ACTION_ONLY 'comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT'' with RESULT_ONLY 'stdout contient COMPARISON_SUCCESS'
[DEBUG] Grammar: Merging ACTION_ONLY 'comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees' with RESULT_ONLY 'stdout contient COMPARISON_SUCCESS'
[DEBUG] Grammar: Merging ACTION_ONLY 'exécuter la requête SELECT COUNT(*) FROM employees' with RESULT_ONLY 'stdout contient un nombre'
[DEBUG] Grammar: Merging ACTION_ONLY 'exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx' with RESULT_ONLY 'stdout contient Excel file created successfully'
[DEBUG] Grammar: Merging ACTION_ONLY 'comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)' with RESULT_ONLY 'stdout contient COMPARISON_SUCCESS'
[DEBUG] Grammar: Merging ACTION_ONLY 'comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)' with RESULT_ONLY 'stdout contient COMPARISON_SUCCESS'
[DEBUG] Grammar: Merging ACTION_ONLY 'comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)' with RESULT_ONLY 'stdout contient COMPARISON_ERROR'
[DEBUG] Grammar: _merge_action_result returning 26 tokens
[DEBUG] get_action_shell_command called with: 'définir la variable SQL_CONN = user/password@testdb'
[DEBUG] canonize_action: Loaded 21 action patterns
[DEBUG] canonize_action: Processing action 'définir la variable SQL_CONN = user/password@testdb' (normalized: 'définir la variable sql_conn = user/password@testdb')
[DEBUG] canonize_action: Checking pattern 'Créer le dossier {path}' with handler 'create_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le dossier (.+)'
[DEBUG] canonize_action: Checking alias '^mkdir (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mkdir (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le dossier {path}' with handler 'delete_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le dossier {src} vers {dest}' with handler 'copy_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le dossier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le dossier {src} vers {dest}' with handler 'move_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Purger le répertoire {path}' with handler 'purge_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Purger\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'vider le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^vider\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nettoyer le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nettoyer\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Checking pattern 'Créer le fichier {path}' with handler 'create_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'générer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^générer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le fichier (.+)'
[DEBUG] canonize_action: Checking alias '^touch (.+)$'
[DEBUG] canonize_action: Testing regex alias '^touch (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le fichier {path}' with handler 'delete_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le fichier {src} vers {dest}' with handler 'copy_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le fichier {src} vers {dest}' with handler 'move_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Afficher le contenu du fichier {path}' with handler 'cat_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Afficher\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'afficher le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^afficher\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cat le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^cat\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cat (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cat (.+)$'
[DEBUG] canonize_action: Checking alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Checking alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script {script}' with handler 'run_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ (.+)$'
[DEBUG] canonize_action: Checking alias 'traiter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^traiter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter traitement.sh'
[DEBUG] canonize_action: Checking alias 'lancer traitement.sh'
[DEBUG] canonize_action: Checking alias 'traiter traitement.sh'
[DEBUG] canonize_action: Checking alias '^sh (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sh (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire tourner le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ tourner\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'démarrer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^démarrer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script SQL {script}' with handler 'run_sql_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script SQL {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter la requête SQL {query}' with handler 'sql_query'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exporter les résultats de la requête {query} vers {output}' with handler 'sql_export'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Comparer les résultats de la requête {query1} avec {query2}' with handler 'sql_compare'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Comparer\ les\ résultats\ de\ la\ requête\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Checking alias 'comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] canonize_action: Testing alias regex '(?i)^comparer\ les\ résultats\ de\ la\ requête\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Checking alias 'comparer les résultats {query1} avec {query2}'
[DEBUG] canonize_action: Testing alias regex '(?i)^comparer\ les\ résultats\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Checking alias 'comparer {query1} avec {query2}'
[DEBUG] canonize_action: Testing alias regex '(?i)^comparer\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Checking alias 'comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] canonize_action: Testing alias regex '(?i)^comparer\ les\ résultats\ de\ la\ requête\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Comparer le fichier {file1} avec {file2}' with handler 'compare_files'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Comparer\ le\ fichier\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Checking alias 'comparer le fichier {file1} avec {file2}'
[DEBUG] canonize_action: Testing alias regex '(?i)^comparer\ le\ fichier\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Checking alias 'comparer le fichier {file1} et {file2}'
[DEBUG] canonize_action: Testing alias regex '(?i)^comparer\ le\ fichier\ (.+)\ et\ (.+)$'
[DEBUG] canonize_action: Checking alias '^diff (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^diff (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Définir la variable {var} = {value}' with handler 'export_var'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Définir\ la\ variable\ (.+)\ =\ (.+)$'
[DEBUG] canonize_action: Found match with pattern 'Définir la variable {var} = {value}'
[DEBUG] get_action_shell_command: canonize_action matched handler 'export_var' for phrase 'Définir la variable {var} = {value}'
[DEBUG] get_action_shell_command: context={'action': 'définir la variable SQL_CONN = user/password@testdb', 'handler': 'export_var', 'category': 'variables', 'variables': {'var': 'SQL_CONN', 'value': 'user/password@testdb'}, 'requirements': {'required_variables': ['var', 'value'], 'optional_variables': [], 'scope': 'global', 'description': 'Export a variable', 'category': 'variables', 'validation_rules': {'var': {'type': 'var', 'required': True, 'pattern': '^[a-zA-Z_][a-zA-Z0-9_]*$'}, 'value': {'type': 'value', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Définir la variable {var} = {value}', 'config': {'type': 'action', 'phrase': 'Définir la variable {var} = {value}', 'aliases': ['définir la variable SQL_CONN = {value}', "définir la variable d'environnement {var} = {value}", 'exporter la variable {var} = {value}', '^export (.+)=(.+)$', 'définir la variable {var} = {value}'], 'handler': 'export_var'}}], 'scope': 'global'}
[DEBUG] get_action_shell_command: handler=export_var, variables={'var': 'SQL_CONN', 'value': 'user/password@testdb'}
[DEBUG] get_action_shell_command: Trying action handler: shtest_compiler.core.action_handlers.export_var
[DEBUG] get_action_shell_command: Calling action handler with params={'context': {'action': 'définir la variable SQL_CONN = user/password@testdb', 'handler': 'export_var', 'category': 'variables', 'variables': {'var': 'SQL_CONN', 'value': 'user/password@testdb'}, 'requirements': {'required_variables': ['var', 'value'], 'optional_variables': [], 'scope': 'global', 'description': 'Export a variable', 'category': 'variables', 'validation_rules': {'var': {'type': 'var', 'required': True, 'pattern': '^[a-zA-Z_][a-zA-Z0-9_]*$'}, 'value': {'type': 'value', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Définir la variable {var} = {value}', 'config': {'type': 'action', 'phrase': 'Définir la variable {var} = {value}', 'aliases': ['définir la variable SQL_CONN = {value}', "définir la variable d'environnement {var} = {value}", 'exporter la variable {var} = {value}', '^export (.+)=(.+)$', 'définir la variable {var} = {value}'], 'handler': 'export_var'}}], 'scope': 'global'}, 'var': 'SQL_CONN', 'value': 'user/password@testdb'}
[DEBUG] get_action_shell_command: Action handler returned=<shtest_compiler.core.action_handlers.export_var.ExportVarAction object at 0x0000027096EA1190>
[DEBUG] get_action_shell_command: Generated shell command: export SQL_CONN='user/password@testdb'
[DEBUG] compile_validation_expression called with: 'variable SQL_CONN vaut user/password@testdb'
[DEBUG] compile_validation_expression: Detected atomic expression, using compile_atomic
[DEBUG] compile_atomic called with: expected='variable SQL_CONN vaut user/password@testdb', varname='result', last_file_var=None, extracted_args=None, action_context={'command': 'définir la variable SQL_CONN = user/password@testdb'}
[DEBUG] compile_atomic: Trying to canonize validation: 'variable SQL_CONN vaut user/password@testdb'
[DEBUG] compile_atomic: canonize_validation('variable SQL_CONN vaut user/password@testdb') result: {'phrase': 'variable {var} vaut {value}', 'handler': 'var_equals', 'scope': 'global', 'pattern_entry': {'phrase': 'variable {var} vaut {value}', 'handler': 'var_equals', 'scope': 'global', 'opposite': {'phrase': 'variable {var} ne vaut pas {value}'}, 'aliases': []}, 'params': {'var': 'sql_conn', 'value': 'user/password@testdb'}}
[DEBUG] extract_context_from_action result: {'action': 'variable SQL_CONN vaut user/password@testdb', 'handler': 'var_equals', 'category': 'variables', 'variables': {'var': 'SQL_CONN', 'value': 'user/password@testdb'}, 'requirements': {'required_variables': ['var', 'value'], 'optional_variables': [], 'scope': 'global', 'description': 'Check if variable equals value', 'category': 'variables', 'validation_rules': {'var': {'type': 'var', 'required': True, 'pattern': '^[a-zA-Z_][a-zA-Z0-9_]*$'}, 'value': {'type': 'value', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'variable {var} vaut {value}', 'config': {'type': 'validation', 'phrase': 'variable {var} vaut {value}', 'aliases': [], 'handler': 'var_equals', 'scope': 'global'}}], 'scope': 'global'}
[DEBUG] Final params for handler: {'var': 'sql_conn', 'value': 'user/password@testdb'}
[DEBUG] Trying to import core handler: shtest_compiler.core.handlers.var_equals
[DEBUG] Core handler returned: ValidationCheck(expected='variable sql_conn vaut user/password@testdb', actual_cmd='test "$sql_conn" = "user/password@testdb"', handler='var_equals', scope='global', params={'var': 'sql_conn', 'value': 'user/password@testdb', 'opposite': 'variable sql_conn ne vaut pas user/password@testdb'})
[DEBUG] get_action_shell_command called with: 'exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx'
[DEBUG] canonize_action: Loaded 21 action patterns
[DEBUG] canonize_action: Processing action 'exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx' (normalized: 'exporter les résultats de la requête select count(*) from employees vers employees_count.xlsx')
[DEBUG] canonize_action: Checking pattern 'Créer le dossier {path}' with handler 'create_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le dossier (.+)'
[DEBUG] canonize_action: Checking alias '^mkdir (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mkdir (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le dossier {path}' with handler 'delete_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le dossier {src} vers {dest}' with handler 'copy_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le dossier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le dossier {src} vers {dest}' with handler 'move_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Purger le répertoire {path}' with handler 'purge_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Purger\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'vider le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^vider\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nettoyer le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nettoyer\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Checking pattern 'Créer le fichier {path}' with handler 'create_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'générer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^générer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le fichier (.+)'
[DEBUG] canonize_action: Checking alias '^touch (.+)$'
[DEBUG] canonize_action: Testing regex alias '^touch (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le fichier {path}' with handler 'delete_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le fichier {src} vers {dest}' with handler 'copy_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le fichier {src} vers {dest}' with handler 'move_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Afficher le contenu du fichier {path}' with handler 'cat_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Afficher\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'afficher le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^afficher\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cat le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^cat\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cat (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cat (.+)$'
[DEBUG] canonize_action: Checking alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Checking alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script {script}' with handler 'run_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ (.+)$'
[DEBUG] canonize_action: Checking alias 'traiter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^traiter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter traitement.sh'
[DEBUG] canonize_action: Checking alias 'lancer traitement.sh'
[DEBUG] canonize_action: Checking alias 'traiter traitement.sh'
[DEBUG] canonize_action: Checking alias '^sh (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sh (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire tourner le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ tourner\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'démarrer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^démarrer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script SQL {script}' with handler 'run_sql_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script SQL {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter la requête SQL {query}' with handler 'sql_query'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exporter les résultats de la requête {query} vers {output}' with handler 'sql_export'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Found match with pattern 'Exporter les résultats de la requête {query} vers {output}'
[DEBUG] get_action_shell_command: canonize_action matched handler 'sql_export' for phrase 'Exporter les résultats de la requête {query} vers {output}'
[DEBUG] get_action_shell_command: context={'action': 'exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx', 'handler': 'sql_export', 'category': 'execution', 'variables': {'query': 'SELECT COUNT(*) FROM employees', 'output': 'employees_count.xlsx'}, 'requirements': {'required_variables': ['query', 'output'], 'optional_variables': [], 'scope': 'global', 'description': 'Export SQL query results', 'category': 'execution', 'validation_rules': {'query': {'type': 'query', 'required': True}, 'output': {'type': 'path', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Exporter les résultats de la requête {query} vers {output}', 'config': {'type': 'action', 'phrase': 'Exporter les résultats de la requête {query} vers {output}', 'aliases': ['exporter les résultats de la requête {query} vers {output}', 'exporter les résultats {query} vers {output}', 'exporter {query} vers {output}', 'exporter les résultats de la requête {query} vers {output}'], 'handler': 'sql_export'}}], 'scope': 'global'}
[DEBUG] get_action_shell_command: handler=sql_export, variables={'query': 'SELECT COUNT(*) FROM employees', 'output': 'employees_count.xlsx'}
[DEBUG] get_action_shell_command: Trying action handler: shtest_compiler.core.action_handlers.sql_export
[DEBUG] get_action_shell_command: Calling action handler with params={'context': {'action': 'exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx', 'handler': 'sql_export', 'category': 'execution', 'variables': {'query': 'SELECT COUNT(*) FROM employees', 'output': 'employees_count.xlsx'}, 'requirements': {'required_variables': ['query', 'output'], 'optional_variables': [], 'scope': 'global', 'description': 'Export SQL query results', 'category': 'execution', 'validation_rules': {'query': {'type': 'query', 'required': True}, 'output': {'type': 'path', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Exporter les résultats de la requête {query} vers {output}', 'config': {'type': 'action', 'phrase': 'Exporter les résultats de la requête {query} vers {output}', 'aliases': ['exporter les résultats de la requête {query} vers {output}', 'exporter les résultats {query} vers {output}', 'exporter {query} vers {output}', 'exporter les résultats de la requête {query} vers {output}'], 'handler': 'sql_export'}}], 'scope': 'global'}, 'query': 'SELECT COUNT(*) FROM employees', 'output': 'employees_count.xlsx'}
[DEBUG] get_action_shell_command: Exception: 'output_file'
[DEBUG] compile_validation_expression called with: 'stdout contient Excel file created successfully'
[DEBUG] compile_validation_expression: Detected atomic expression, using compile_atomic
[DEBUG] compile_atomic called with: expected='stdout contient Excel file created successfully', varname='result', last_file_var=None, extracted_args=None, action_context={'command': 'exporter les résultats de la requête SELECT COUNT(*) FROM employees vers employees_count.xlsx'}
[DEBUG] compile_atomic: Trying to canonize validation: 'stdout contient Excel file created successfully'
[DEBUG] compile_atomic: canonize_validation('stdout contient Excel file created successfully') result: {'phrase': '^stdout contient (.+)$', 'handler': 'stdout_contains', 'scope': 'last_action', 'pattern_entry': {'phrase': 'La sortie standard contient {text}', 'handler': 'stdout_contains', 'scope': 'last_action', 'opposite': {'phrase': 'La sortie standard ne contient pas {text}'}, 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$']}, 'params': {'text': 'excel file created successfully'}}
[DEBUG] extract_context_from_action result: {'action': 'stdout contient Excel file created successfully', 'handler': 'stdout_contains', 'category': 'validation', 'variables': {'text': 'Excel file created successfully'}, 'requirements': {'required_variables': ['text'], 'optional_variables': [], 'scope': 'last_action', 'description': 'Check if stdout contains text', 'category': 'validation', 'validation_rules': {'text': {'type': 'text', 'required': True}}}, 'patterns_matched': [{'type': 'alias', 'pattern': 'stdout contient {text}', 'config': {'type': 'validation', 'phrase': 'La sortie standard contient {text}', 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$'], 'handler': 'stdout_contains', 'scope': 'last_action'}}], 'scope': 'last_action'}
[DEBUG] Final params for handler: {'text': 'excel file created successfully'}
[DEBUG] Trying to import core handler: shtest_compiler.core.handlers.stdout_contains
[DEBUG] Core handler returned: ValidationCheck(expected='stdout contient excel file created successfully', actual_cmd='echo "$stdout" | grep -q "excel file created successfully"', handler='stdout_contains', scope='global', params={'text': 'excel file created successfully', 'opposite': 'stdout ne contient pas excel file created successfully'})
[DEBUG] get_action_shell_command called with: 'comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT''
[DEBUG] canonize_action: Loaded 21 action patterns
[DEBUG] canonize_action: Processing action 'comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT'' (normalized: 'comparer les résultats de la requête select * from employees where department = 'it' avec select * from employees where department = 'it'')
[DEBUG] canonize_action: Checking pattern 'Créer le dossier {path}' with handler 'create_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le dossier (.+)'
[DEBUG] canonize_action: Checking alias '^mkdir (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mkdir (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le dossier {path}' with handler 'delete_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le dossier {src} vers {dest}' with handler 'copy_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le dossier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le dossier {src} vers {dest}' with handler 'move_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Purger le répertoire {path}' with handler 'purge_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Purger\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'vider le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^vider\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nettoyer le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nettoyer\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Checking pattern 'Créer le fichier {path}' with handler 'create_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'générer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^générer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le fichier (.+)'
[DEBUG] canonize_action: Checking alias '^touch (.+)$'
[DEBUG] canonize_action: Testing regex alias '^touch (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le fichier {path}' with handler 'delete_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le fichier {src} vers {dest}' with handler 'copy_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le fichier {src} vers {dest}' with handler 'move_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Afficher le contenu du fichier {path}' with handler 'cat_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Afficher\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'afficher le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^afficher\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cat le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^cat\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cat (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cat (.+)$'
[DEBUG] canonize_action: Checking alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Checking alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script {script}' with handler 'run_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ (.+)$'
[DEBUG] canonize_action: Checking alias 'traiter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^traiter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter traitement.sh'
[DEBUG] canonize_action: Checking alias 'lancer traitement.sh'
[DEBUG] canonize_action: Checking alias 'traiter traitement.sh'
[DEBUG] canonize_action: Checking alias '^sh (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sh (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire tourner le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ tourner\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'démarrer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^démarrer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script SQL {script}' with handler 'run_sql_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script SQL {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter la requête SQL {query}' with handler 'sql_query'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exporter les résultats de la requête {query} vers {output}' with handler 'sql_export'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Comparer les résultats de la requête {query1} avec {query2}' with handler 'sql_compare'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Comparer\ les\ résultats\ de\ la\ requête\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Found match with pattern 'Comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] get_action_shell_command: canonize_action matched handler 'sql_compare' for phrase 'Comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] get_action_shell_command: context={'action': "comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT'", 'handler': 'sql_compare', 'category': 'execution', 'variables': {'query1': "SELECT * FROM employees WHERE department = 'IT'", 'query2': "SELECT * FROM employees WHERE department = 'IT'"}, 'requirements': {'required_variables': ['query1', 'query2'], 'optional_variables': [], 'scope': 'global', 'description': 'Compare SQL query results', 'category': 'execution', 'validation_rules': {'query1': {'type': 'query', 'required': True}, 'query2': {'type': 'query', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Comparer les résultats de la requête {query1} avec {query2}', 'config': {'type': 'action', 'phrase': 'Comparer les résultats de la requête {query1} avec {query2}', 'aliases': [{'comparer les résultats de la requête {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer les résultats {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, 'comparer les résultats de la requête {query1} avec {query2}', 'comparer les résultats {query1} avec {query2}', 'comparer {query1} avec {query2}', 'comparer les résultats de la requête {query1} avec {query2}'], 'handler': 'sql_compare'}}], 'scope': 'global'}
[DEBUG] get_action_shell_command: handler=sql_compare, variables={'query1': "SELECT * FROM employees WHERE department = 'IT'", 'query2': "SELECT * FROM employees WHERE department = 'IT'"}
[DEBUG] get_action_shell_command: Trying action handler: shtest_compiler.core.action_handlers.sql_compare
[DEBUG] get_action_shell_command: Calling action handler with params={'context': {'action': "comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT'", 'handler': 'sql_compare', 'category': 'execution', 'variables': {'query1': "SELECT * FROM employees WHERE department = 'IT'", 'query2': "SELECT * FROM employees WHERE department = 'IT'"}, 'requirements': {'required_variables': ['query1', 'query2'], 'optional_variables': [], 'scope': 'global', 'description': 'Compare SQL query results', 'category': 'execution', 'validation_rules': {'query1': {'type': 'query', 'required': True}, 'query2': {'type': 'query', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Comparer les résultats de la requête {query1} avec {query2}', 'config': {'type': 'action', 'phrase': 'Comparer les résultats de la requête {query1} avec {query2}', 'aliases': [{'comparer les résultats de la requête {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer les résultats {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, 'comparer les résultats de la requête {query1} avec {query2}', 'comparer les résultats {query1} avec {query2}', 'comparer {query1} avec {query2}', 'comparer les résultats de la requête {query1} avec {query2}'], 'handler': 'sql_compare'}}], 'scope': 'global'}, 'query1': "SELECT * FROM employees WHERE department = 'IT'", 'query2': "SELECT * FROM employees WHERE department = 'IT'"}
[DEBUG] get_action_shell_command: Action handler returned=<shtest_compiler.core.action_handlers.sql_compare.SQLCompareAction object at 0x0000027096EA1A90>
[DEBUG] get_action_shell_command: Generated shell command: cat > temp_query_876.sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET LINESIZE 1000
SET TRIMSPOOL ON
SET TRIMOUT ON
SELECT * FROM employees WHERE department = 'IT'
EOF
sqlplus -s  @temp_query_876.sql > temp_csv_876.csv
python3 -c "
import pandas as pd
import sys
try:
    df = pd.read_csv('temp_csv_876.csv', header=None)
    df.to_excel('temp_compare_1_876.xlsx', index=False, header=False)
    print('Excel file created successfully')
except Exception as e:
    print(f'Error converting to Excel: {e}', file=sys.stderr)
    sys.exit(1)
"
rm -f temp_query_876.sql temp_csv_876.csv && cat > temp_query_876.sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET LINESIZE 1000
SET TRIMSPOOL ON
SET TRIMOUT ON
SELECT * FROM employees WHERE department = 'IT'
EOF
sqlplus -s  @temp_query_876.sql > temp_csv_876.csv
python3 -c "
import pandas as pd
import sys
try:
    df = pd.read_csv('temp_csv_876.csv', header=None)
    df.to_excel('temp_compare_2_876.xlsx', index=False, header=False)
    print('Excel file created successfully')
except Exception as e:
    print(f'Error converting to Excel: {e}', file=sys.stderr)
    sys.exit(1)
"
rm -f temp_query_876.sql temp_csv_876.csv && python3 -c "
import pandas as pd
import numpy as np
import sys

def compare_excel_files(file1, file2, tolerance=0.0, ignore_order=False):
    try:
        df1 = pd.read_excel(file1, header=None)
        df2 = pd.read_excel(file2, header=None)
        for col in df1.columns:
            try:
                df1[col] = pd.to_numeric(df1[col], errors='ignore')
                df2[col] = pd.to_numeric(df2[col], errors='ignore')
            except:
                pass
        if ignore_order:
            df1_sorted = df1.sort_values(by=list(df1.columns)).reset_index(drop=True)
            df2_sorted = df2.sort_values(by=list(df2.columns)).reset_index(drop=True)
        else:
            df1_sorted = df1.reset_index(drop=True)
            df2_sorted = df2.reset_index(drop=True)
        if df1_sorted.shape != df2_sorted.shape:
            print(f'SHAPE_MISMATCH: {df1_sorted.shape} vs {df2_sorted.shape}')
            return False
        if tolerance > 0:
            numeric_cols = df1_sorted.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                diff = np.abs(df1_sorted[numeric_cols] - df2_sorted[numeric_cols])
                if (diff > tolerance).any().any():
                    print(f'TOLERANCE_EXCEEDED: Max difference {diff.max().max()} > {tolerance}')
                    return False
        if not df1_sorted.equals(df2_sorted):
            print('EXACT_MISMATCH: Values differ')
            return False
        print('COMPARISON_SUCCESS: Files are identical')
        return True
    except Exception as e:
        print(f'COMPARISON_ERROR: {e}')
        return False
success = compare_excel_files('temp_compare_1_876.xlsx', 'temp_compare_2_876.xlsx')
if not success:
    sys.exit(1)
" && rm -f temp_compare_1_876.xlsx temp_compare_2_876.xlsx
[DEBUG] compile_validation_expression called with: 'stdout contient COMPARISON_SUCCESS'
[DEBUG] compile_validation_expression: Detected atomic expression, using compile_atomic
[DEBUG] compile_atomic called with: expected='stdout contient COMPARISON_SUCCESS', varname='result', last_file_var=None, extracted_args=None, action_context={'command': "comparer les résultats de la requête SELECT * FROM employees WHERE department = 'IT' avec SELECT * FROM employees WHERE department = 'IT'"}
[DEBUG] compile_atomic: Trying to canonize validation: 'stdout contient COMPARISON_SUCCESS'
[DEBUG] compile_atomic: canonize_validation('stdout contient COMPARISON_SUCCESS') result: {'phrase': '^stdout contient (.+)$', 'handler': 'stdout_contains', 'scope': 'last_action', 'pattern_entry': {'phrase': 'La sortie standard contient {text}', 'handler': 'stdout_contains', 'scope': 'last_action', 'opposite': {'phrase': 'La sortie standard ne contient pas {text}'}, 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$']}, 'params': {'text': 'comparison_success'}}
[DEBUG] extract_context_from_action result: {'action': 'stdout contient COMPARISON_SUCCESS', 'handler': 'stdout_contains', 'category': 'validation', 'variables': {'text': 'COMPARISON_SUCCESS'}, 'requirements': {'required_variables': ['text'], 'optional_variables': [], 'scope': 'last_action', 'description': 'Check if stdout contains text', 'category': 'validation', 'validation_rules': {'text': {'type': 'text', 'required': True}}}, 'patterns_matched': [{'type': 'alias', 'pattern': 'stdout contient {text}', 'config': {'type': 'validation', 'phrase': 'La sortie standard contient {text}', 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$'], 'handler': 'stdout_contains', 'scope': 'last_action'}}], 'scope': 'last_action'}
[DEBUG] Final params for handler: {'text': 'comparison_success'}
[DEBUG] Trying to import core handler: shtest_compiler.core.handlers.stdout_contains
[DEBUG] Core handler returned: ValidationCheck(expected='stdout contient comparison_success', actual_cmd='echo "$stdout" | grep -q "comparison_success"', handler='stdout_contains', scope='global', params={'text': 'comparison_success', 'opposite': 'stdout ne contient pas comparison_success'})
[DEBUG] get_action_shell_command called with: 'comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees'
[DEBUG] canonize_action: Loaded 21 action patterns
[DEBUG] canonize_action: Processing action 'comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees' (normalized: 'comparer les résultats de la requête select avg(salary) from employees avec select avg(salary) from employees')
[DEBUG] canonize_action: Checking pattern 'Créer le dossier {path}' with handler 'create_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le dossier (.+)'
[DEBUG] canonize_action: Checking alias '^mkdir (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mkdir (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le dossier {path}' with handler 'delete_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le dossier {src} vers {dest}' with handler 'copy_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le dossier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le dossier {src} vers {dest}' with handler 'move_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Purger le répertoire {path}' with handler 'purge_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Purger\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'vider le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^vider\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nettoyer le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nettoyer\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Checking pattern 'Créer le fichier {path}' with handler 'create_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'générer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^générer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le fichier (.+)'
[DEBUG] canonize_action: Checking alias '^touch (.+)$'
[DEBUG] canonize_action: Testing regex alias '^touch (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le fichier {path}' with handler 'delete_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le fichier {src} vers {dest}' with handler 'copy_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le fichier {src} vers {dest}' with handler 'move_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Afficher le contenu du fichier {path}' with handler 'cat_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Afficher\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'afficher le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^afficher\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cat le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^cat\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cat (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cat (.+)$'
[DEBUG] canonize_action: Checking alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Checking alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script {script}' with handler 'run_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ (.+)$'
[DEBUG] canonize_action: Checking alias 'traiter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^traiter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter traitement.sh'
[DEBUG] canonize_action: Checking alias 'lancer traitement.sh'
[DEBUG] canonize_action: Checking alias 'traiter traitement.sh'
[DEBUG] canonize_action: Checking alias '^sh (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sh (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire tourner le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ tourner\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'démarrer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^démarrer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script SQL {script}' with handler 'run_sql_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script SQL {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter la requête SQL {query}' with handler 'sql_query'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exporter les résultats de la requête {query} vers {output}' with handler 'sql_export'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Comparer les résultats de la requête {query1} avec {query2}' with handler 'sql_compare'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Comparer\ les\ résultats\ de\ la\ requête\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Found match with pattern 'Comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] get_action_shell_command: canonize_action matched handler 'sql_compare' for phrase 'Comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] get_action_shell_command: context={'action': 'comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees', 'handler': 'sql_compare', 'category': 'execution', 'variables': {'query1': 'SELECT AVG(salary) FROM employees', 'query2': 'SELECT AVG(salary) FROM employees'}, 'requirements': {'required_variables': ['query1', 'query2'], 'optional_variables': [], 'scope': 'global', 'description': 'Compare SQL query results', 'category': 'execution', 'validation_rules': {'query1': {'type': 'query', 'required': True}, 'query2': {'type': 'query', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Comparer les résultats de la requête {query1} avec {query2}', 'config': {'type': 'action', 'phrase': 'Comparer les résultats de la requête {query1} avec {query2}', 'aliases': [{'comparer les résultats de la requête {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer les résultats {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, 'comparer les résultats de la requête {query1} avec {query2}', 'comparer les résultats {query1} avec {query2}', 'comparer {query1} avec {query2}', 'comparer les résultats de la requête {query1} avec {query2}'], 'handler': 'sql_compare'}}], 'scope': 'global'}
[DEBUG] get_action_shell_command: handler=sql_compare, variables={'query1': 'SELECT AVG(salary) FROM employees', 'query2': 'SELECT AVG(salary) FROM employees'}
[DEBUG] get_action_shell_command: Trying action handler: shtest_compiler.core.action_handlers.sql_compare
[DEBUG] get_action_shell_command: Calling action handler with params={'context': {'action': 'comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees', 'handler': 'sql_compare', 'category': 'execution', 'variables': {'query1': 'SELECT AVG(salary) FROM employees', 'query2': 'SELECT AVG(salary) FROM employees'}, 'requirements': {'required_variables': ['query1', 'query2'], 'optional_variables': [], 'scope': 'global', 'description': 'Compare SQL query results', 'category': 'execution', 'validation_rules': {'query1': {'type': 'query', 'required': True}, 'query2': {'type': 'query', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Comparer les résultats de la requête {query1} avec {query2}', 'config': {'type': 'action', 'phrase': 'Comparer les résultats de la requête {query1} avec {query2}', 'aliases': [{'comparer les résultats de la requête {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer les résultats {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, 'comparer les résultats de la requête {query1} avec {query2}', 'comparer les résultats {query1} avec {query2}', 'comparer {query1} avec {query2}', 'comparer les résultats de la requête {query1} avec {query2}'], 'handler': 'sql_compare'}}], 'scope': 'global'}, 'query1': 'SELECT AVG(salary) FROM employees', 'query2': 'SELECT AVG(salary) FROM employees'}
[DEBUG] get_action_shell_command: Action handler returned=<shtest_compiler.core.action_handlers.sql_compare.SQLCompareAction object at 0x0000027096EA1A90>
[DEBUG] get_action_shell_command: Generated shell command: cat > temp_query_8256.sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET LINESIZE 1000
SET TRIMSPOOL ON
SET TRIMOUT ON
SELECT AVG(salary) FROM employees
EOF
sqlplus -s  @temp_query_8256.sql > temp_csv_8256.csv
python3 -c "
import pandas as pd
import sys
try:
    df = pd.read_csv('temp_csv_8256.csv', header=None)
    df.to_excel('temp_compare_1_8256.xlsx', index=False, header=False)
    print('Excel file created successfully')
except Exception as e:
    print(f'Error converting to Excel: {e}', file=sys.stderr)
    sys.exit(1)
"
rm -f temp_query_8256.sql temp_csv_8256.csv && cat > temp_query_8256.sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET LINESIZE 1000
SET TRIMSPOOL ON
SET TRIMOUT ON
SELECT AVG(salary) FROM employees
EOF
sqlplus -s  @temp_query_8256.sql > temp_csv_8256.csv
python3 -c "
import pandas as pd
import sys
try:
    df = pd.read_csv('temp_csv_8256.csv', header=None)
    df.to_excel('temp_compare_2_8256.xlsx', index=False, header=False)
    print('Excel file created successfully')
except Exception as e:
    print(f'Error converting to Excel: {e}', file=sys.stderr)
    sys.exit(1)
"
rm -f temp_query_8256.sql temp_csv_8256.csv && python3 -c "
import pandas as pd
import numpy as np
import sys

def compare_excel_files(file1, file2, tolerance=0.0, ignore_order=False):
    try:
        df1 = pd.read_excel(file1, header=None)
        df2 = pd.read_excel(file2, header=None)
        for col in df1.columns:
            try:
                df1[col] = pd.to_numeric(df1[col], errors='ignore')
                df2[col] = pd.to_numeric(df2[col], errors='ignore')
            except:
                pass
        if ignore_order:
            df1_sorted = df1.sort_values(by=list(df1.columns)).reset_index(drop=True)
            df2_sorted = df2.sort_values(by=list(df2.columns)).reset_index(drop=True)
        else:
            df1_sorted = df1.reset_index(drop=True)
            df2_sorted = df2.reset_index(drop=True)
        if df1_sorted.shape != df2_sorted.shape:
            print(f'SHAPE_MISMATCH: {df1_sorted.shape} vs {df2_sorted.shape}')
            return False
        if tolerance > 0:
            numeric_cols = df1_sorted.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                diff = np.abs(df1_sorted[numeric_cols] - df2_sorted[numeric_cols])
                if (diff > tolerance).any().any():
                    print(f'TOLERANCE_EXCEEDED: Max difference {diff.max().max()} > {tolerance}')
                    return False
        if not df1_sorted.equals(df2_sorted):
            print('EXACT_MISMATCH: Values differ')
            return False
        print('COMPARISON_SUCCESS: Files are identical')
        return True
    except Exception as e:
        print(f'COMPARISON_ERROR: {e}')
        return False
success = compare_excel_files('temp_compare_1_8256.xlsx', 'temp_compare_2_8256.xlsx')
if not success:
    sys.exit(1)
" && rm -f temp_compare_1_8256.xlsx temp_compare_2_8256.xlsx
[DEBUG] compile_validation_expression called with: 'stdout contient COMPARISON_SUCCESS'
[DEBUG] compile_validation_expression: Detected atomic expression, using compile_atomic
[DEBUG] compile_atomic called with: expected='stdout contient COMPARISON_SUCCESS', varname='result', last_file_var=None, extracted_args=None, action_context={'command': 'comparer les résultats de la requête SELECT AVG(salary) FROM employees avec SELECT AVG(salary) FROM employees'}
[DEBUG] compile_atomic: Trying to canonize validation: 'stdout contient COMPARISON_SUCCESS'
[DEBUG] compile_atomic: canonize_validation('stdout contient COMPARISON_SUCCESS') result: {'phrase': '^stdout contient (.+)$', 'handler': 'stdout_contains', 'scope': 'last_action', 'pattern_entry': {'phrase': 'La sortie standard contient {text}', 'handler': 'stdout_contains', 'scope': 'last_action', 'opposite': {'phrase': 'La sortie standard ne contient pas {text}'}, 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$']}, 'params': {'text': 'comparison_success'}}
[DEBUG] extract_context_from_action result: {'action': 'stdout contient COMPARISON_SUCCESS', 'handler': 'stdout_contains', 'category': 'validation', 'variables': {'text': 'COMPARISON_SUCCESS'}, 'requirements': {'required_variables': ['text'], 'optional_variables': [], 'scope': 'last_action', 'description': 'Check if stdout contains text', 'category': 'validation', 'validation_rules': {'text': {'type': 'text', 'required': True}}}, 'patterns_matched': [{'type': 'alias', 'pattern': 'stdout contient {text}', 'config': {'type': 'validation', 'phrase': 'La sortie standard contient {text}', 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$'], 'handler': 'stdout_contains', 'scope': 'last_action'}}], 'scope': 'last_action'}
[DEBUG] Final params for handler: {'text': 'comparison_success'}
[DEBUG] Trying to import core handler: shtest_compiler.core.handlers.stdout_contains
[DEBUG] Core handler returned: ValidationCheck(expected='stdout contient comparison_success', actual_cmd='echo "$stdout" | grep -q "comparison_success"', handler='stdout_contains', scope='global', params={'text': 'comparison_success', 'opposite': 'stdout ne contient pas comparison_success'})
[DEBUG] get_action_shell_command called with: 'exécuter la requête SELECT COUNT(*) FROM employees'
[DEBUG] canonize_action: Loaded 21 action patterns
[DEBUG] canonize_action: Processing action 'exécuter la requête SELECT COUNT(*) FROM employees' (normalized: 'exécuter la requête select count(*) from employees')
[DEBUG] canonize_action: Checking pattern 'Créer le dossier {path}' with handler 'create_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le dossier (.+)'
[DEBUG] canonize_action: Checking alias '^mkdir (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mkdir (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le dossier {path}' with handler 'delete_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le dossier {src} vers {dest}' with handler 'copy_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le dossier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le dossier {src} vers {dest}' with handler 'move_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Purger le répertoire {path}' with handler 'purge_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Purger\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'vider le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^vider\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nettoyer le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nettoyer\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Checking pattern 'Créer le fichier {path}' with handler 'create_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'générer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^générer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le fichier (.+)'
[DEBUG] canonize_action: Checking alias '^touch (.+)$'
[DEBUG] canonize_action: Testing regex alias '^touch (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le fichier {path}' with handler 'delete_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le fichier {src} vers {dest}' with handler 'copy_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le fichier {src} vers {dest}' with handler 'move_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Afficher le contenu du fichier {path}' with handler 'cat_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Afficher\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'afficher le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^afficher\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cat le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^cat\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cat (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cat (.+)$'
[DEBUG] canonize_action: Checking alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Checking alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script {script}' with handler 'run_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ (.+)$'
[DEBUG] canonize_action: Found match with alias 'exécuter {script}'
[DEBUG] get_action_shell_command: canonize_action matched handler 'run_script' for phrase 'Exécuter le script {script}'
[DEBUG] get_action_shell_command: context={'action': 'exécuter la requête SELECT COUNT(*) FROM employees', 'handler': 'run_script', 'category': 'execution', 'variables': {'script': 'la requête SELECT COUNT(*) FROM employees'}, 'requirements': {'required_variables': ['script'], 'optional_variables': [], 'scope': 'global', 'description': 'Execute a shell script', 'category': 'execution', 'validation_rules': {'script': {'type': 'script', 'required': True}}}, 'patterns_matched': [{'type': 'alias', 'pattern': 'exécuter {script}', 'config': {'type': 'action', 'phrase': 'Exécuter le script {script}', 'aliases': ['exécuter {script}', 'lancer {script}', 'traiter {script}', 'exécuter traitement.sh', 'lancer traitement.sh', 'traiter traitement.sh', '^sh (.+)$', 'lancer le script {script}', 'faire tourner le script {script}', 'démarrer le script {script}'], 'handler': 'run_script'}}], 'scope': 'global'}
[DEBUG] get_action_shell_command: handler=run_script, variables={'script': 'la requête SELECT COUNT(*) FROM employees'}
[DEBUG] get_action_shell_command: Trying action handler: shtest_compiler.core.action_handlers.run_script
[DEBUG] get_action_shell_command: Calling action handler with params={'context': {'action': 'exécuter la requête SELECT COUNT(*) FROM employees', 'handler': 'run_script', 'category': 'execution', 'variables': {'script': 'la requête SELECT COUNT(*) FROM employees'}, 'requirements': {'required_variables': ['script'], 'optional_variables': [], 'scope': 'global', 'description': 'Execute a shell script', 'category': 'execution', 'validation_rules': {'script': {'type': 'script', 'required': True}}}, 'patterns_matched': [{'type': 'alias', 'pattern': 'exécuter {script}', 'config': {'type': 'action', 'phrase': 'Exécuter le script {script}', 'aliases': ['exécuter {script}', 'lancer {script}', 'traiter {script}', 'exécuter traitement.sh', 'lancer traitement.sh', 'traiter traitement.sh', '^sh (.+)$', 'lancer le script {script}', 'faire tourner le script {script}', 'démarrer le script {script}'], 'handler': 'run_script'}}], 'scope': 'global'}, 'script': 'la requête SELECT COUNT(*) FROM employees'}
[DEBUG] get_action_shell_command: Action handler returned=<shtest_compiler.core.action_handlers.run_script.RunScriptAction object at 0x0000027096EABA50>
[DEBUG] get_action_shell_command: Generated shell command: sh 'la requête SELECT COUNT(*) FROM employees'
[DEBUG] compile_validation_expression called with: 'stdout contient un nombre'
[DEBUG] compile_validation_expression: Detected atomic expression, using compile_atomic
[DEBUG] compile_atomic called with: expected='stdout contient un nombre', varname='result', last_file_var=None, extracted_args=None, action_context={'command': 'exécuter la requête SELECT COUNT(*) FROM employees'}
[DEBUG] compile_atomic: Trying to canonize validation: 'stdout contient un nombre'
[DEBUG] compile_atomic: canonize_validation('stdout contient un nombre') result: {'phrase': '^stdout contient (.+)$', 'handler': 'stdout_contains', 'scope': 'last_action', 'pattern_entry': {'phrase': 'La sortie standard contient {text}', 'handler': 'stdout_contains', 'scope': 'last_action', 'opposite': {'phrase': 'La sortie standard ne contient pas {text}'}, 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$']}, 'params': {'text': 'un nombre'}}
[DEBUG] extract_context_from_action result: {'action': 'stdout contient un nombre', 'handler': 'stdout_contains', 'category': 'validation', 'variables': {'text': 'un nombre'}, 'requirements': {'required_variables': ['text'], 'optional_variables': [], 'scope': 'last_action', 'description': 'Check if stdout contains text', 'category': 'validation', 'validation_rules': {'text': {'type': 'text', 'required': True}}}, 'patterns_matched': [{'type': 'alias', 'pattern': 'stdout contient {text}', 'config': {'type': 'validation', 'phrase': 'La sortie standard contient {text}', 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$'], 'handler': 'stdout_contains', 'scope': 'last_action'}}], 'scope': 'last_action'}
[DEBUG] Final params for handler: {'text': 'un nombre'}
[DEBUG] Trying to import core handler: shtest_compiler.core.handlers.stdout_contains
[DEBUG] Core handler returned: ValidationCheck(expected='stdout contient un nombre', actual_cmd='echo "$stdout" | grep -q "un nombre"', handler='stdout_contains', scope='global', params={'text': 'un nombre', 'opposite': 'stdout ne contient pas un nombre'})
[DEBUG] get_action_shell_command called with: 'exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx'
[DEBUG] canonize_action: Loaded 21 action patterns
[DEBUG] canonize_action: Processing action 'exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx' (normalized: 'exporter les résultats de la requête select name, salary from employees order by salary desc vers top_salaries.xlsx')
[DEBUG] canonize_action: Checking pattern 'Créer le dossier {path}' with handler 'create_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le dossier (.+)'
[DEBUG] canonize_action: Checking alias '^mkdir (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mkdir (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le dossier {path}' with handler 'delete_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le dossier {src} vers {dest}' with handler 'copy_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le dossier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le dossier {src} vers {dest}' with handler 'move_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Purger le répertoire {path}' with handler 'purge_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Purger\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'vider le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^vider\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nettoyer le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nettoyer\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Checking pattern 'Créer le fichier {path}' with handler 'create_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'générer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^générer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le fichier (.+)'
[DEBUG] canonize_action: Checking alias '^touch (.+)$'
[DEBUG] canonize_action: Testing regex alias '^touch (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le fichier {path}' with handler 'delete_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le fichier {src} vers {dest}' with handler 'copy_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le fichier {src} vers {dest}' with handler 'move_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Afficher le contenu du fichier {path}' with handler 'cat_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Afficher\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'afficher le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^afficher\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cat le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^cat\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cat (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cat (.+)$'
[DEBUG] canonize_action: Checking alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Checking alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script {script}' with handler 'run_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ (.+)$'
[DEBUG] canonize_action: Checking alias 'traiter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^traiter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter traitement.sh'
[DEBUG] canonize_action: Checking alias 'lancer traitement.sh'
[DEBUG] canonize_action: Checking alias 'traiter traitement.sh'
[DEBUG] canonize_action: Checking alias '^sh (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sh (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire tourner le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ tourner\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'démarrer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^démarrer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script SQL {script}' with handler 'run_sql_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script SQL {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter la requête SQL {query}' with handler 'sql_query'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exporter les résultats de la requête {query} vers {output}' with handler 'sql_export'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Found match with pattern 'Exporter les résultats de la requête {query} vers {output}'
[DEBUG] get_action_shell_command: canonize_action matched handler 'sql_export' for phrase 'Exporter les résultats de la requête {query} vers {output}'
[DEBUG] get_action_shell_command: context={'action': 'exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx', 'handler': 'sql_export', 'category': 'execution', 'variables': {'query': 'SELECT name, salary FROM employees ORDER BY salary DESC', 'output': 'top_salaries.xlsx'}, 'requirements': {'required_variables': ['query', 'output'], 'optional_variables': [], 'scope': 'global', 'description': 'Export SQL query results', 'category': 'execution', 'validation_rules': {'query': {'type': 'query', 'required': True}, 'output': {'type': 'path', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Exporter les résultats de la requête {query} vers {output}', 'config': {'type': 'action', 'phrase': 'Exporter les résultats de la requête {query} vers {output}', 'aliases': ['exporter les résultats de la requête {query} vers {output}', 'exporter les résultats {query} vers {output}', 'exporter {query} vers {output}', 'exporter les résultats de la requête {query} vers {output}'], 'handler': 'sql_export'}}], 'scope': 'global'}
[DEBUG] get_action_shell_command: handler=sql_export, variables={'query': 'SELECT name, salary FROM employees ORDER BY salary DESC', 'output': 'top_salaries.xlsx'}
[DEBUG] get_action_shell_command: Trying action handler: shtest_compiler.core.action_handlers.sql_export
[DEBUG] get_action_shell_command: Calling action handler with params={'context': {'action': 'exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx', 'handler': 'sql_export', 'category': 'execution', 'variables': {'query': 'SELECT name, salary FROM employees ORDER BY salary DESC', 'output': 'top_salaries.xlsx'}, 'requirements': {'required_variables': ['query', 'output'], 'optional_variables': [], 'scope': 'global', 'description': 'Export SQL query results', 'category': 'execution', 'validation_rules': {'query': {'type': 'query', 'required': True}, 'output': {'type': 'path', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Exporter les résultats de la requête {query} vers {output}', 'config': {'type': 'action', 'phrase': 'Exporter les résultats de la requête {query} vers {output}', 'aliases': ['exporter les résultats de la requête {query} vers {output}', 'exporter les résultats {query} vers {output}', 'exporter {query} vers {output}', 'exporter les résultats de la requête {query} vers {output}'], 'handler': 'sql_export'}}], 'scope': 'global'}, 'query': 'SELECT name, salary FROM employees ORDER BY salary DESC', 'output': 'top_salaries.xlsx'}
[DEBUG] get_action_shell_command: Exception: 'output_file'
[DEBUG] compile_validation_expression called with: 'stdout contient Excel file created successfully'
[DEBUG] compile_validation_expression: Detected atomic expression, using compile_atomic
[DEBUG] compile_atomic called with: expected='stdout contient Excel file created successfully', varname='result', last_file_var=None, extracted_args=None, action_context={'command': 'exporter les résultats de la requête SELECT name, salary FROM employees ORDER BY salary DESC vers top_salaries.xlsx'}
[DEBUG] compile_atomic: Trying to canonize validation: 'stdout contient Excel file created successfully'
[DEBUG] compile_atomic: canonize_validation('stdout contient Excel file created successfully') result: {'phrase': '^stdout contient (.+)$', 'handler': 'stdout_contains', 'scope': 'last_action', 'pattern_entry': {'phrase': 'La sortie standard contient {text}', 'handler': 'stdout_contains', 'scope': 'last_action', 'opposite': {'phrase': 'La sortie standard ne contient pas {text}'}, 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$']}, 'params': {'text': 'excel file created successfully'}}
[DEBUG] extract_context_from_action result: {'action': 'stdout contient Excel file created successfully', 'handler': 'stdout_contains', 'category': 'validation', 'variables': {'text': 'Excel file created successfully'}, 'requirements': {'required_variables': ['text'], 'optional_variables': [], 'scope': 'last_action', 'description': 'Check if stdout contains text', 'category': 'validation', 'validation_rules': {'text': {'type': 'text', 'required': True}}}, 'patterns_matched': [{'type': 'alias', 'pattern': 'stdout contient {text}', 'config': {'type': 'validation', 'phrase': 'La sortie standard contient {text}', 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$'], 'handler': 'stdout_contains', 'scope': 'last_action'}}], 'scope': 'last_action'}
[DEBUG] Final params for handler: {'text': 'excel file created successfully'}
[DEBUG] Trying to import core handler: shtest_compiler.core.handlers.stdout_contains
[DEBUG] Core handler returned: ValidationCheck(expected='stdout contient excel file created successfully', actual_cmd='echo "$stdout" | grep -q "excel file created successfully"', handler='stdout_contains', scope='global', params={'text': 'excel file created successfully', 'opposite': 'stdout ne contient pas excel file created successfully'})
[DEBUG] get_action_shell_command called with: 'comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)'
[DEBUG] canonize_action: Loaded 21 action patterns
[DEBUG] canonize_action: Processing action 'comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)' (normalized: 'comparer les résultats de la requête select name, department from employees order by name avec select name, department from employees order by department (ignorer l'ordre lors de la comparaison)')
[DEBUG] canonize_action: Checking pattern 'Créer le dossier {path}' with handler 'create_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le dossier (.+)'
[DEBUG] canonize_action: Checking alias '^mkdir (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mkdir (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le dossier {path}' with handler 'delete_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le dossier {src} vers {dest}' with handler 'copy_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le dossier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le dossier {src} vers {dest}' with handler 'move_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Purger le répertoire {path}' with handler 'purge_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Purger\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'vider le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^vider\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nettoyer le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nettoyer\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Checking pattern 'Créer le fichier {path}' with handler 'create_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'générer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^générer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le fichier (.+)'
[DEBUG] canonize_action: Checking alias '^touch (.+)$'
[DEBUG] canonize_action: Testing regex alias '^touch (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le fichier {path}' with handler 'delete_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le fichier {src} vers {dest}' with handler 'copy_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le fichier {src} vers {dest}' with handler 'move_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Afficher le contenu du fichier {path}' with handler 'cat_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Afficher\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'afficher le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^afficher\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cat le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^cat\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cat (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cat (.+)$'
[DEBUG] canonize_action: Checking alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Checking alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script {script}' with handler 'run_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ (.+)$'
[DEBUG] canonize_action: Checking alias 'traiter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^traiter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter traitement.sh'
[DEBUG] canonize_action: Checking alias 'lancer traitement.sh'
[DEBUG] canonize_action: Checking alias 'traiter traitement.sh'
[DEBUG] canonize_action: Checking alias '^sh (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sh (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire tourner le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ tourner\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'démarrer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^démarrer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script SQL {script}' with handler 'run_sql_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script SQL {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter la requête SQL {query}' with handler 'sql_query'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exporter les résultats de la requête {query} vers {output}' with handler 'sql_export'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Comparer les résultats de la requête {query1} avec {query2}' with handler 'sql_compare'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Comparer\ les\ résultats\ de\ la\ requête\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Found match with pattern 'Comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] get_action_shell_command: canonize_action matched handler 'sql_compare' for phrase 'Comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] get_action_shell_command: context={'action': "comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)", 'handler': 'sql_compare', 'category': 'execution', 'variables': {'query1': 'SELECT name, department FROM employees ORDER BY name', 'query2': "SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)"}, 'requirements': {'required_variables': ['query1', 'query2'], 'optional_variables': [], 'scope': 'global', 'description': 'Compare SQL query results', 'category': 'execution', 'validation_rules': {'query1': {'type': 'query', 'required': True}, 'query2': {'type': 'query', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Comparer les résultats de la requête {query1} avec {query2}', 'config': {'type': 'action', 'phrase': 'Comparer les résultats de la requête {query1} avec {query2}', 'aliases': [{'comparer les résultats de la requête {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer les résultats {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, 'comparer les résultats de la requête {query1} avec {query2}', 'comparer les résultats {query1} avec {query2}', 'comparer {query1} avec {query2}', 'comparer les résultats de la requête {query1} avec {query2}'], 'handler': 'sql_compare'}}], 'scope': 'global'}
[DEBUG] get_action_shell_command: handler=sql_compare, variables={'query1': 'SELECT name, department FROM employees ORDER BY name', 'query2': "SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)"}
[DEBUG] get_action_shell_command: Trying action handler: shtest_compiler.core.action_handlers.sql_compare
[DEBUG] get_action_shell_command: Calling action handler with params={'context': {'action': "comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)", 'handler': 'sql_compare', 'category': 'execution', 'variables': {'query1': 'SELECT name, department FROM employees ORDER BY name', 'query2': "SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)"}, 'requirements': {'required_variables': ['query1', 'query2'], 'optional_variables': [], 'scope': 'global', 'description': 'Compare SQL query results', 'category': 'execution', 'validation_rules': {'query1': {'type': 'query', 'required': True}, 'query2': {'type': 'query', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Comparer les résultats de la requête {query1} avec {query2}', 'config': {'type': 'action', 'phrase': 'Comparer les résultats de la requête {query1} avec {query2}', 'aliases': [{'comparer les résultats de la requête {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer les résultats {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, 'comparer les résultats de la requête {query1} avec {query2}', 'comparer les résultats {query1} avec {query2}', 'comparer {query1} avec {query2}', 'comparer les résultats de la requête {query1} avec {query2}'], 'handler': 'sql_compare'}}], 'scope': 'global'}, 'query1': 'SELECT name, department FROM employees ORDER BY name', 'query2': "SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)"}
[DEBUG] get_action_shell_command: Action handler returned=<shtest_compiler.core.action_handlers.sql_compare.SQLCompareAction object at 0x000002709726DB50>
[DEBUG] get_action_shell_command: Generated shell command: cat > temp_query_7602.sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET LINESIZE 1000
SET TRIMSPOOL ON
SET TRIMOUT ON
SELECT name, department FROM employees ORDER BY name
EOF
sqlplus -s  @temp_query_7602.sql > temp_csv_7602.csv
python3 -c "
import pandas as pd
import sys
try:
    df = pd.read_csv('temp_csv_7602.csv', header=None)
    df.to_excel('temp_compare_1_7602.xlsx', index=False, header=False)
    print('Excel file created successfully')
except Exception as e:
    print(f'Error converting to Excel: {e}', file=sys.stderr)
    sys.exit(1)
"
rm -f temp_query_7602.sql temp_csv_7602.csv && cat > temp_query_6287.sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET LINESIZE 1000
SET TRIMSPOOL ON
SET TRIMOUT ON
SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)
EOF
sqlplus -s  @temp_query_6287.sql > temp_csv_6287.csv
python3 -c "
import pandas as pd
import sys
try:
    df = pd.read_csv('temp_csv_6287.csv', header=None)
    df.to_excel('temp_compare_2_6287.xlsx', index=False, header=False)
    print('Excel file created successfully')
except Exception as e:
    print(f'Error converting to Excel: {e}', file=sys.stderr)
    sys.exit(1)
"
rm -f temp_query_6287.sql temp_csv_6287.csv && python3 -c "
import pandas as pd
import numpy as np
import sys

def compare_excel_files(file1, file2, tolerance=0.0, ignore_order=False):
    try:
        df1 = pd.read_excel(file1, header=None)
        df2 = pd.read_excel(file2, header=None)
        for col in df1.columns:
            try:
                df1[col] = pd.to_numeric(df1[col], errors='ignore')
                df2[col] = pd.to_numeric(df2[col], errors='ignore')
            except:
                pass
        if ignore_order:
            df1_sorted = df1.sort_values(by=list(df1.columns)).reset_index(drop=True)
            df2_sorted = df2.sort_values(by=list(df2.columns)).reset_index(drop=True)
        else:
            df1_sorted = df1.reset_index(drop=True)
            df2_sorted = df2.reset_index(drop=True)
        if df1_sorted.shape != df2_sorted.shape:
            print(f'SHAPE_MISMATCH: {df1_sorted.shape} vs {df2_sorted.shape}')
            return False
        if tolerance > 0:
            numeric_cols = df1_sorted.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                diff = np.abs(df1_sorted[numeric_cols] - df2_sorted[numeric_cols])
                if (diff > tolerance).any().any():
                    print(f'TOLERANCE_EXCEEDED: Max difference {diff.max().max()} > {tolerance}')
                    return False
        if not df1_sorted.equals(df2_sorted):
            print('EXACT_MISMATCH: Values differ')
            return False
        print('COMPARISON_SUCCESS: Files are identical')
        return True
    except Exception as e:
        print(f'COMPARISON_ERROR: {e}')
        return False
success = compare_excel_files('temp_compare_1_7602.xlsx', 'temp_compare_2_6287.xlsx')
if not success:
    sys.exit(1)
" && rm -f temp_compare_1_7602.xlsx temp_compare_2_6287.xlsx
[DEBUG] compile_validation_expression called with: 'stdout contient COMPARISON_SUCCESS'
[DEBUG] compile_validation_expression: Detected atomic expression, using compile_atomic
[DEBUG] compile_atomic called with: expected='stdout contient COMPARISON_SUCCESS', varname='result', last_file_var=None, extracted_args=None, action_context={'command': "comparer les résultats de la requête SELECT name, department FROM employees ORDER BY name avec SELECT name, department FROM employees ORDER BY department (ignorer l'ordre lors de la comparaison)"}
[DEBUG] compile_atomic: Trying to canonize validation: 'stdout contient COMPARISON_SUCCESS'
[DEBUG] compile_atomic: canonize_validation('stdout contient COMPARISON_SUCCESS') result: {'phrase': '^stdout contient (.+)$', 'handler': 'stdout_contains', 'scope': 'last_action', 'pattern_entry': {'phrase': 'La sortie standard contient {text}', 'handler': 'stdout_contains', 'scope': 'last_action', 'opposite': {'phrase': 'La sortie standard ne contient pas {text}'}, 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$']}, 'params': {'text': 'comparison_success'}}
[DEBUG] extract_context_from_action result: {'action': 'stdout contient COMPARISON_SUCCESS', 'handler': 'stdout_contains', 'category': 'validation', 'variables': {'text': 'COMPARISON_SUCCESS'}, 'requirements': {'required_variables': ['text'], 'optional_variables': [], 'scope': 'last_action', 'description': 'Check if stdout contains text', 'category': 'validation', 'validation_rules': {'text': {'type': 'text', 'required': True}}}, 'patterns_matched': [{'type': 'alias', 'pattern': 'stdout contient {text}', 'config': {'type': 'validation', 'phrase': 'La sortie standard contient {text}', 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$'], 'handler': 'stdout_contains', 'scope': 'last_action'}}], 'scope': 'last_action'}
[DEBUG] Final params for handler: {'text': 'comparison_success'}
[DEBUG] Trying to import core handler: shtest_compiler.core.handlers.stdout_contains
[DEBUG] Core handler returned: ValidationCheck(expected='stdout contient comparison_success', actual_cmd='echo "$stdout" | grep -q "comparison_success"', handler='stdout_contains', scope='global', params={'text': 'comparison_success', 'opposite': 'stdout ne contient pas comparison_success'})
[DEBUG] get_action_shell_command called with: 'comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)'
[DEBUG] canonize_action: Loaded 21 action patterns
[DEBUG] canonize_action: Processing action 'comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)' (normalized: 'comparer les résultats de la requête select id, name, salary from employees where department = 'hr' order by salary avec select id, name, salary from employees where department = 'hr' order by name (ignorer l'ordre lors de la comparaison)')
[DEBUG] canonize_action: Checking pattern 'Créer le dossier {path}' with handler 'create_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le dossier (.+)'
[DEBUG] canonize_action: Checking alias '^mkdir (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mkdir (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le dossier {path}' with handler 'delete_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le dossier {src} vers {dest}' with handler 'copy_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le dossier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le dossier {src} vers {dest}' with handler 'move_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Purger le répertoire {path}' with handler 'purge_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Purger\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'vider le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^vider\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nettoyer le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nettoyer\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Checking pattern 'Créer le fichier {path}' with handler 'create_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'générer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^générer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le fichier (.+)'
[DEBUG] canonize_action: Checking alias '^touch (.+)$'
[DEBUG] canonize_action: Testing regex alias '^touch (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le fichier {path}' with handler 'delete_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le fichier {src} vers {dest}' with handler 'copy_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le fichier {src} vers {dest}' with handler 'move_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Afficher le contenu du fichier {path}' with handler 'cat_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Afficher\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'afficher le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^afficher\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cat le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^cat\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cat (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cat (.+)$'
[DEBUG] canonize_action: Checking alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Checking alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script {script}' with handler 'run_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ (.+)$'
[DEBUG] canonize_action: Checking alias 'traiter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^traiter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter traitement.sh'
[DEBUG] canonize_action: Checking alias 'lancer traitement.sh'
[DEBUG] canonize_action: Checking alias 'traiter traitement.sh'
[DEBUG] canonize_action: Checking alias '^sh (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sh (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire tourner le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ tourner\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'démarrer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^démarrer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script SQL {script}' with handler 'run_sql_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script SQL {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter la requête SQL {query}' with handler 'sql_query'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exporter les résultats de la requête {query} vers {output}' with handler 'sql_export'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Comparer les résultats de la requête {query1} avec {query2}' with handler 'sql_compare'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Comparer\ les\ résultats\ de\ la\ requête\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Found match with pattern 'Comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] get_action_shell_command: canonize_action matched handler 'sql_compare' for phrase 'Comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] get_action_shell_command: context={'action': "comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)", 'handler': 'sql_compare', 'category': 'execution', 'variables': {'query1': "SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary", 'query2': "SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)"}, 'requirements': {'required_variables': ['query1', 'query2'], 'optional_variables': [], 'scope': 'global', 'description': 'Compare SQL query results', 'category': 'execution', 'validation_rules': {'query1': {'type': 'query', 'required': True}, 'query2': {'type': 'query', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Comparer les résultats de la requête {query1} avec {query2}', 'config': {'type': 'action', 'phrase': 'Comparer les résultats de la requête {query1} avec {query2}', 'aliases': [{'comparer les résultats de la requête {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer les résultats {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, 'comparer les résultats de la requête {query1} avec {query2}', 'comparer les résultats {query1} avec {query2}', 'comparer {query1} avec {query2}', 'comparer les résultats de la requête {query1} avec {query2}'], 'handler': 'sql_compare'}}], 'scope': 'global'}
[DEBUG] get_action_shell_command: handler=sql_compare, variables={'query1': "SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary", 'query2': "SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)"}
[DEBUG] get_action_shell_command: Trying action handler: shtest_compiler.core.action_handlers.sql_compare
[DEBUG] get_action_shell_command: Calling action handler with params={'context': {'action': "comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)", 'handler': 'sql_compare', 'category': 'execution', 'variables': {'query1': "SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary", 'query2': "SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)"}, 'requirements': {'required_variables': ['query1', 'query2'], 'optional_variables': [], 'scope': 'global', 'description': 'Compare SQL query results', 'category': 'execution', 'validation_rules': {'query1': {'type': 'query', 'required': True}, 'query2': {'type': 'query', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Comparer les résultats de la requête {query1} avec {query2}', 'config': {'type': 'action', 'phrase': 'Comparer les résultats de la requête {query1} avec {query2}', 'aliases': [{'comparer les résultats de la requête {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer les résultats {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, 'comparer les résultats de la requête {query1} avec {query2}', 'comparer les résultats {query1} avec {query2}', 'comparer {query1} avec {query2}', 'comparer les résultats de la requête {query1} avec {query2}'], 'handler': 'sql_compare'}}], 'scope': 'global'}, 'query1': "SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary", 'query2': "SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)"}
[DEBUG] get_action_shell_command: Action handler returned=<shtest_compiler.core.action_handlers.sql_compare.SQLCompareAction object at 0x0000027096E8F9D0>
[DEBUG] get_action_shell_command: Generated shell command: cat > temp_query_7545.sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET LINESIZE 1000
SET TRIMSPOOL ON
SET TRIMOUT ON
SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary
EOF
sqlplus -s  @temp_query_7545.sql > temp_csv_7545.csv
python3 -c "
import pandas as pd
import sys
try:
    df = pd.read_csv('temp_csv_7545.csv', header=None)
    df.to_excel('temp_compare_1_7545.xlsx', index=False, header=False)
    print('Excel file created successfully')
except Exception as e:
    print(f'Error converting to Excel: {e}', file=sys.stderr)
    sys.exit(1)
"
rm -f temp_query_7545.sql temp_csv_7545.csv && cat > temp_query_5522.sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET LINESIZE 1000
SET TRIMSPOOL ON
SET TRIMOUT ON
SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)
EOF
sqlplus -s  @temp_query_5522.sql > temp_csv_5522.csv
python3 -c "
import pandas as pd
import sys
try:
    df = pd.read_csv('temp_csv_5522.csv', header=None)
    df.to_excel('temp_compare_2_5522.xlsx', index=False, header=False)
    print('Excel file created successfully')
except Exception as e:
    print(f'Error converting to Excel: {e}', file=sys.stderr)
    sys.exit(1)
"
rm -f temp_query_5522.sql temp_csv_5522.csv && python3 -c "
import pandas as pd
import numpy as np
import sys

def compare_excel_files(file1, file2, tolerance=0.0, ignore_order=False):
    try:
        df1 = pd.read_excel(file1, header=None)
        df2 = pd.read_excel(file2, header=None)
        for col in df1.columns:
            try:
                df1[col] = pd.to_numeric(df1[col], errors='ignore')
                df2[col] = pd.to_numeric(df2[col], errors='ignore')
            except:
                pass
        if ignore_order:
            df1_sorted = df1.sort_values(by=list(df1.columns)).reset_index(drop=True)
            df2_sorted = df2.sort_values(by=list(df2.columns)).reset_index(drop=True)
        else:
            df1_sorted = df1.reset_index(drop=True)
            df2_sorted = df2.reset_index(drop=True)
        if df1_sorted.shape != df2_sorted.shape:
            print(f'SHAPE_MISMATCH: {df1_sorted.shape} vs {df2_sorted.shape}')
            return False
        if tolerance > 0:
            numeric_cols = df1_sorted.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                diff = np.abs(df1_sorted[numeric_cols] - df2_sorted[numeric_cols])
                if (diff > tolerance).any().any():
                    print(f'TOLERANCE_EXCEEDED: Max difference {diff.max().max()} > {tolerance}')
                    return False
        if not df1_sorted.equals(df2_sorted):
            print('EXACT_MISMATCH: Values differ')
            return False
        print('COMPARISON_SUCCESS: Files are identical')
        return True
    except Exception as e:
        print(f'COMPARISON_ERROR: {e}')
        return False
success = compare_excel_files('temp_compare_1_7545.xlsx', 'temp_compare_2_5522.xlsx')
if not success:
    sys.exit(1)
" && rm -f temp_compare_1_7545.xlsx temp_compare_2_5522.xlsx
[DEBUG] compile_validation_expression called with: 'stdout contient COMPARISON_SUCCESS'
[DEBUG] compile_validation_expression: Detected atomic expression, using compile_atomic
[DEBUG] compile_atomic called with: expected='stdout contient COMPARISON_SUCCESS', varname='result', last_file_var=None, extracted_args=None, action_context={'command': "comparer les résultats de la requête SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY salary avec SELECT id, name, salary FROM employees WHERE department = 'HR' ORDER BY name (ignorer l'ordre lors de la comparaison)"}
[DEBUG] compile_atomic: Trying to canonize validation: 'stdout contient COMPARISON_SUCCESS'
[DEBUG] compile_atomic: canonize_validation('stdout contient COMPARISON_SUCCESS') result: {'phrase': '^stdout contient (.+)$', 'handler': 'stdout_contains', 'scope': 'last_action', 'pattern_entry': {'phrase': 'La sortie standard contient {text}', 'handler': 'stdout_contains', 'scope': 'last_action', 'opposite': {'phrase': 'La sortie standard ne contient pas {text}'}, 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$']}, 'params': {'text': 'comparison_success'}}
[DEBUG] extract_context_from_action result: {'action': 'stdout contient COMPARISON_SUCCESS', 'handler': 'stdout_contains', 'category': 'validation', 'variables': {'text': 'COMPARISON_SUCCESS'}, 'requirements': {'required_variables': ['text'], 'optional_variables': [], 'scope': 'last_action', 'description': 'Check if stdout contains text', 'category': 'validation', 'validation_rules': {'text': {'type': 'text', 'required': True}}}, 'patterns_matched': [{'type': 'alias', 'pattern': 'stdout contient {text}', 'config': {'type': 'validation', 'phrase': 'La sortie standard contient {text}', 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$'], 'handler': 'stdout_contains', 'scope': 'last_action'}}], 'scope': 'last_action'}
[DEBUG] Final params for handler: {'text': 'comparison_success'}
[DEBUG] Trying to import core handler: shtest_compiler.core.handlers.stdout_contains
[DEBUG] Core handler returned: ValidationCheck(expected='stdout contient comparison_success', actual_cmd='echo "$stdout" | grep -q "comparison_success"', handler='stdout_contains', scope='global', params={'text': 'comparison_success', 'opposite': 'stdout ne contient pas comparison_success'})
[DEBUG] get_action_shell_command called with: 'comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)'
[DEBUG] canonize_action: Loaded 21 action patterns
[DEBUG] canonize_action: Processing action 'comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)' (normalized: 'comparer les résultats de la requête select name from employees where department = 'it' avec select name from employees where department = 'hr' (ignorer l'ordre lors de la comparaison)')
[DEBUG] canonize_action: Checking pattern 'Créer le dossier {path}' with handler 'create_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le dossier (.+)'
[DEBUG] canonize_action: Checking alias '^mkdir (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mkdir (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le dossier {path}' with handler 'delete_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le dossier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ dossier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le dossier {src} vers {dest}' with handler 'copy_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le dossier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp -r (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le dossier {src} vers {dest}' with handler 'move_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ dossier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le dossier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ dossier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking pattern 'Purger le répertoire {path}' with handler 'purge_dir'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Purger\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'vider le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^vider\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nettoyer le répertoire {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nettoyer\ le\ répertoire\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Testing regex alias '^rm -rf (.+)/\\*$'
[DEBUG] canonize_action: Checking pattern 'Créer le fichier {path}' with handler 'create_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Créer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'créer un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^créer\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire un fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ un\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'générer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^générer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'nouveau fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^nouveau\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cr[ée]er le fichier (.+)'
[DEBUG] canonize_action: Checking alias '^touch (.+)$'
[DEBUG] canonize_action: Testing regex alias '^touch (.+)$'
[DEBUG] canonize_action: Checking pattern 'Supprimer le fichier {path}' with handler 'delete_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Supprimer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'effacer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^effacer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'enlever le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^enlever\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'retirer le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^retirer\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias '^rm (.+)$'
[DEBUG] canonize_action: Testing regex alias '^rm (.+)$'
[DEBUG] canonize_action: Checking pattern 'Copier le fichier {src} vers {dest}' with handler 'copy_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'dupliquer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^dupliquer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cp (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'copier le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^copier\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Déplacer le fichier {src} vers {dest}' with handler 'move_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} à {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ à\ (.+)$'
[DEBUG] canonize_action: Checking alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Testing regex alias '^mv (.+) (.+)$'
[DEBUG] canonize_action: Checking alias 'déplacer le fichier {src} vers {dest}'
[DEBUG] canonize_action: Testing alias regex '(?i)^déplacer\ le\ fichier\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Afficher le contenu du fichier {path}' with handler 'cat_file'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Afficher\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'afficher le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^afficher\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'cat le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^cat\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier = {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ =\ (.+)$'
[DEBUG] canonize_action: Checking alias '^cat (.+)$'
[DEBUG] canonize_action: Testing regex alias '^cat (.+)$'
[DEBUG] canonize_action: Checking alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^afficher le contenu du fichier = (.+)$'
[DEBUG] canonize_action: Checking alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Testing regex alias '^lire le fichier = (.+)$'
[DEBUG] canonize_action: Checking alias 'voir le contenu du fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^voir\ le\ contenu\ du\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lire le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lire\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'consulter le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^consulter\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking alias 'ouvrir le fichier {path}'
[DEBUG] canonize_action: Testing alias regex '(?i)^ouvrir\ le\ fichier\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script {script}' with handler 'run_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ (.+)$'
[DEBUG] canonize_action: Checking alias 'traiter {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^traiter\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter traitement.sh'
[DEBUG] canonize_action: Checking alias 'lancer traitement.sh'
[DEBUG] canonize_action: Checking alias 'traiter traitement.sh'
[DEBUG] canonize_action: Checking alias '^sh (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sh (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'faire tourner le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^faire\ tourner\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking alias 'démarrer le script {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^démarrer\ le\ script\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter le script SQL {script}' with handler 'run_sql_script'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script SQL {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer le script sql {script}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ le\ script\ sql\ (.+)$'
[DEBUG] canonize_action: Checking alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Testing regex alias '^sqlplus (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exécuter la requête SQL {query}' with handler 'sql_query'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête SQL {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ SQL\ (.+)$'
[DEBUG] canonize_action: Checking alias 'lancer la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^lancer\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exécuter la requête {query}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exécuter\ la\ requête\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Exporter les résultats de la requête {query} vers {output}' with handler 'sql_export'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking alias 'exporter les résultats de la requête {query} vers {output}'
[DEBUG] canonize_action: Testing alias regex '(?i)^exporter\ les\ résultats\ de\ la\ requête\ (.+)\ vers\ (.+)$'
[DEBUG] canonize_action: Checking pattern 'Comparer les résultats de la requête {query1} avec {query2}' with handler 'sql_compare'
[DEBUG] canonize_action: Testing regex pattern '(?i)^Comparer\ les\ résultats\ de\ la\ requête\ (.+)\ avec\ (.+)$'
[DEBUG] canonize_action: Found match with pattern 'Comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] get_action_shell_command: canonize_action matched handler 'sql_compare' for phrase 'Comparer les résultats de la requête {query1} avec {query2}'
[DEBUG] get_action_shell_command: context={'action': "comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)", 'handler': 'sql_compare', 'category': 'execution', 'variables': {'query1': "SELECT name FROM employees WHERE department = 'IT'", 'query2': "SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)"}, 'requirements': {'required_variables': ['query1', 'query2'], 'optional_variables': [], 'scope': 'global', 'description': 'Compare SQL query results', 'category': 'execution', 'validation_rules': {'query1': {'type': 'query', 'required': True}, 'query2': {'type': 'query', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Comparer les résultats de la requête {query1} avec {query2}', 'config': {'type': 'action', 'phrase': 'Comparer les résultats de la requête {query1} avec {query2}', 'aliases': [{'comparer les résultats de la requête {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer les résultats {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, 'comparer les résultats de la requête {query1} avec {query2}', 'comparer les résultats {query1} avec {query2}', 'comparer {query1} avec {query2}', 'comparer les résultats de la requête {query1} avec {query2}'], 'handler': 'sql_compare'}}], 'scope': 'global'}
[DEBUG] get_action_shell_command: handler=sql_compare, variables={'query1': "SELECT name FROM employees WHERE department = 'IT'", 'query2': "SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)"}
[DEBUG] get_action_shell_command: Trying action handler: shtest_compiler.core.action_handlers.sql_compare
[DEBUG] get_action_shell_command: Calling action handler with params={'context': {'action': "comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)", 'handler': 'sql_compare', 'category': 'execution', 'variables': {'query1': "SELECT name FROM employees WHERE department = 'IT'", 'query2': "SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)"}, 'requirements': {'required_variables': ['query1', 'query2'], 'optional_variables': [], 'scope': 'global', 'description': 'Compare SQL query results', 'category': 'execution', 'validation_rules': {'query1': {'type': 'query', 'required': True}, 'query2': {'type': 'query', 'required': True}}}, 'patterns_matched': [{'type': 'phrase', 'pattern': 'Comparer les résultats de la requête {query1} avec {query2}', 'config': {'type': 'action', 'phrase': 'Comparer les résultats de la requête {query1} avec {query2}', 'aliases': [{'comparer les résultats de la requête {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer les résultats {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, {'comparer {query1} avec {query2}(?': "\\\\(ignorer l'ordre lors de la comparaison\\\\))?"}, 'comparer les résultats de la requête {query1} avec {query2}', 'comparer les résultats {query1} avec {query2}', 'comparer {query1} avec {query2}', 'comparer les résultats de la requête {query1} avec {query2}'], 'handler': 'sql_compare'}}], 'scope': 'global'}, 'query1': "SELECT name FROM employees WHERE department = 'IT'", 'query2': "SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)"}
[DEBUG] get_action_shell_command: Action handler returned=<shtest_compiler.core.action_handlers.sql_compare.SQLCompareAction object at 0x00000270972E7790>
[DEBUG] get_action_shell_command: Generated shell command: cat > temp_query_5367.sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET LINESIZE 1000
SET TRIMSPOOL ON
SET TRIMOUT ON
SELECT name FROM employees WHERE department = 'IT'
EOF
sqlplus -s  @temp_query_5367.sql > temp_csv_5367.csv
python3 -c "
import pandas as pd
import sys
try:
    df = pd.read_csv('temp_csv_5367.csv', header=None)
    df.to_excel('temp_compare_1_5367.xlsx', index=False, header=False)
    print('Excel file created successfully')
except Exception as e:
    print(f'Error converting to Excel: {e}', file=sys.stderr)
    sys.exit(1)
"
rm -f temp_query_5367.sql temp_csv_5367.csv && cat > temp_query_8153.sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET LINESIZE 1000
SET TRIMSPOOL ON
SET TRIMOUT ON
SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)
EOF
sqlplus -s  @temp_query_8153.sql > temp_csv_8153.csv
python3 -c "
import pandas as pd
import sys
try:
    df = pd.read_csv('temp_csv_8153.csv', header=None)
    df.to_excel('temp_compare_2_8153.xlsx', index=False, header=False)
    print('Excel file created successfully')
except Exception as e:
    print(f'Error converting to Excel: {e}', file=sys.stderr)
    sys.exit(1)
"
rm -f temp_query_8153.sql temp_csv_8153.csv && python3 -c "
import pandas as pd
import numpy as np
import sys

def compare_excel_files(file1, file2, tolerance=0.0, ignore_order=False):
    try:
        df1 = pd.read_excel(file1, header=None)
        df2 = pd.read_excel(file2, header=None)
        for col in df1.columns:
            try:
                df1[col] = pd.to_numeric(df1[col], errors='ignore')
                df2[col] = pd.to_numeric(df2[col], errors='ignore')
            except:
                pass
        if ignore_order:
            df1_sorted = df1.sort_values(by=list(df1.columns)).reset_index(drop=True)
            df2_sorted = df2.sort_values(by=list(df2.columns)).reset_index(drop=True)
        else:
            df1_sorted = df1.reset_index(drop=True)
            df2_sorted = df2.reset_index(drop=True)
        if df1_sorted.shape != df2_sorted.shape:
            print(f'SHAPE_MISMATCH: {df1_sorted.shape} vs {df2_sorted.shape}')
            return False
        if tolerance > 0:
            numeric_cols = df1_sorted.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                diff = np.abs(df1_sorted[numeric_cols] - df2_sorted[numeric_cols])
                if (diff > tolerance).any().any():
                    print(f'TOLERANCE_EXCEEDED: Max difference {diff.max().max()} > {tolerance}')
                    return False
        if not df1_sorted.equals(df2_sorted):
            print('EXACT_MISMATCH: Values differ')
            return False
        print('COMPARISON_SUCCESS: Files are identical')
        return True
    except Exception as e:
        print(f'COMPARISON_ERROR: {e}')
        return False
success = compare_excel_files('temp_compare_1_5367.xlsx', 'temp_compare_2_8153.xlsx')
if not success:
    sys.exit(1)
" && rm -f temp_compare_1_5367.xlsx temp_compare_2_8153.xlsx
[DEBUG] compile_validation_expression called with: 'stdout contient COMPARISON_ERROR'
[DEBUG] compile_validation_expression: Detected atomic expression, using compile_atomic
[DEBUG] compile_atomic called with: expected='stdout contient COMPARISON_ERROR', varname='result', last_file_var=None, extracted_args=None, action_context={'command': "comparer les résultats de la requête SELECT name FROM employees WHERE department = 'IT' avec SELECT name FROM employees WHERE department = 'HR' (ignorer l'ordre lors de la comparaison)"}
[DEBUG] compile_atomic: Trying to canonize validation: 'stdout contient COMPARISON_ERROR'
[DEBUG] compile_atomic: canonize_validation('stdout contient COMPARISON_ERROR') result: {'phrase': '^stdout contient (.+)$', 'handler': 'stdout_contains', 'scope': 'last_action', 'pattern_entry': {'phrase': 'La sortie standard contient {text}', 'handler': 'stdout_contains', 'scope': 'last_action', 'opposite': {'phrase': 'La sortie standard ne contient pas {text}'}, 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$']}, 'params': {'text': 'comparison_error'}}
[DEBUG] extract_context_from_action result: {'action': 'stdout contient COMPARISON_ERROR', 'handler': 'stdout_contains', 'category': 'validation', 'variables': {'text': 'COMPARISON_ERROR'}, 'requirements': {'required_variables': ['text'], 'optional_variables': [], 'scope': 'last_action', 'description': 'Check if stdout contains text', 'category': 'validation', 'validation_rules': {'text': {'type': 'text', 'required': True}}}, 'patterns_matched': [{'type': 'alias', 'pattern': 'stdout contient {text}', 'config': {'type': 'validation', 'phrase': 'La sortie standard contient {text}', 'aliases': ['stdout contient {text}', 'la sortie contient {text}', 'la sortie standard affiche {text}', '^stdout contient (.+)$', '^la sortie standard contient (.+)$'], 'handler': 'stdout_contains', 'scope': 'last_action'}}], 'scope': 'last_action'}
[DEBUG] Final params for handler: {'text': 'comparison_error'}
[DEBUG] Trying to import core handler: shtest_compiler.core.handlers.stdout_contains
[DEBUG] Core handler returned: ValidationCheck(expected='stdout contient comparison_error', actual_cmd='echo "$stdout" | grep -q "comparison_error"', handler='stdout_contains', scope='global', params={'text': 'comparison_error', 'opposite': 'stdout ne contient pas comparison_error'})
Compiled C:\Users\Sventer\OneDrive\Documents\batch testing\src\tests\e2e\sql_comparison_example.shtest -> C:\Users\Sventer\OneDrive\Documents\batch testing\src\tests\e2e\sql_comparison_example.sh
